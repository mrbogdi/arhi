<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORE-ARCH Enterprise v7.0 | Platinum Architect Suite</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background: #f8f9fa; color: #202124; }
        .google-card { background: white; border: 1px solid #dadce0; border-radius: 8px; transition: all 0.2s; }
        .google-card:hover { box-shadow: 0 1px 6px rgba(32,33,36,0.28); }
        .sidebar-item { border-radius: 0 25px 25px 0; transition: all 0.2s; cursor: pointer; border-left: 4px solid transparent; }
        .sidebar-item.active { background: #e8f0fe; color: #1967d2; font-weight: 600; border-left: 4px solid #1a73e8; }
        .input-field { border: 1px solid #dadce0; border-radius: 4px; padding: 10px; width: 100%; outline: none; transition: border 0.2s; background: white; font-weight: 600; font-size: 14px; color: #1a73e8; }
        .input-field:focus { border: 2px solid #1a73e8; padding: 9px; box-shadow: 0 0 0 4px rgba(26,115,232,0.1); }
        .btn-primary { background: #1a73e8; color: white; padding: 10px 24px; border-radius: 4px; font-weight: 500; transition: all 0.3s; }
        .btn-primary:hover { background: #1765cc; transform: translateY(-1px); box-shadow: 0 4px 6px rgba(26,115,232,0.2); }
        
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-thumb { background: #dadce0; border-radius: 10px; }
        .category-title { px-6; mt-6; mb-2; text-[10px]; font-bold; text-gray-400; uppercase; tracking-widest; padding-left: 24px; padding-top: 20px; }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <header class="h-16 border-b bg-white flex items-center justify-between px-6 sticky top-0 z-50 shadow-sm">
        <div class="flex items-center gap-4">
            <div class="text-blue-600"><i data-lucide="layers" class="w-8 h-8"></i></div>
            <h1 class="text-xl text-gray-700 font-medium tracking-tight">CORE-ARCH <span class="font-bold text-gray-900">Enterprise</span> <span class="text-sm bg-blue-100 text-blue-700 px-2 py-0.5 rounded ml-2">v7.0 Platinum</span></h1>
        </div>
        <div class="flex items-center gap-4">
            <div class="hidden md:flex items-center bg-gray-100 rounded-full px-4 py-1.5 mr-4">
                <span class="w-2 h-2 bg-green-500 rounded-full animate-pulse mr-2"></span>
                <span class="text-[10px] font-bold text-gray-600 uppercase">Expert Mode: Normative 2025 Active</span>
            </div>
            <button onclick="exportToPDF()" class="btn-primary flex items-center gap-2 text-sm">
                <i data-lucide="file-check-2" class="w-4 h-4"></i> Exportă Raport Tehnic Premium
            </button>
        </div>
    </header>

    <div class="flex flex-1 overflow-hidden">
        <nav class="w-80 bg-white border-r pt-6 flex flex-col gap-1 overflow-y-auto shadow-inner pb-10">
            <div class="category-title">Business & Taxe</div>
            <div id="nav-management"></div>

            <div class="category-title">Arhitectură & Urbanism</div>
            <div id="nav-architecture"></div>

            <div class="category-title">Precizie Pante (MODERNIZAT)</div>
            <div id="nav-slopes"></div>

            <div class="category-title">Structură & Eurocod</div>
            <div id="nav-structural"></div>

            <div class="category-title">Fizică & nZEB Plus</div>
            <div id="nav-physics"></div>

            <div class="category-title">Inovative 2025 (NOU)</div>
            <div id="nav-innovation"></div>

            <div class="category-title">Specialități & Șantier</div>
            <div id="nav-specialty"></div>
        </nav>

        <main class="flex-1 overflow-y-auto p-8 bg-[#f8f9fa]">
            <div class="max-w-6xl mx-auto grid grid-cols-12 gap-8">
                <div class="col-span-12 lg:col-span-8 space-y-6">
                    <div id="module-header" class="mb-4">
                        <div class="flex items-center gap-2 mb-1">
                            <span id="breadcrumb" class="text-[10px] font-bold text-blue-600 uppercase tracking-widest">ENGINE V7.0 PLATINUM CORE</span>
                        </div>
                        <h2 class="text-3xl font-semibold text-gray-900" id="current-title">Manager Proiect</h2>
                        <p class="text-gray-500 text-sm mt-1" id="current-desc">Selectați un modul de calcul avansat.</p>
                    </div>
                    <div id="input-container" class="google-card p-8 grid grid-cols-1 md:grid-cols-2 gap-6"></div>
                </div>

                <div class="col-span-12 lg:col-span-4 space-y-6">
                    <div class="google-card overflow-hidden">
                        <div class="p-3 border-b bg-gray-50 flex justify-between items-center">
                            <span class="text-[10px] font-bold text-gray-500 uppercase">Simulare 3D Interactivă</span>
                            <div class="flex gap-2">
                                <i data-lucide="move" class="w-3 h-3 text-blue-400" title="Rotire: Click Stânga"></i>
                                <i data-lucide="search-code" class="w-3 h-3 text-blue-400" title="Zoom: Scroll"></i>
                            </div>
                        </div>
                        <div id="three-viewport" class="h-64 bg-slate-50 w-full cursor-grab active:cursor-grabbing"></div>
                    </div>

                    <div class="google-card p-6 border-l-4 border-l-blue-600 bg-white">
                        <span class="text-[11px] font-bold text-gray-400 uppercase tracking-widest">Rezultat Principal</span>
                        <div class="mt-1 flex items-baseline gap-2">
                            <span id="res-main" class="text-4xl font-bold text-gray-900">0.00</span>
                            <span id="res-unit" class="text-lg font-medium text-blue-600">UNIT</span>
                        </div>
                        <div id="res-secondary" class="mt-6 space-y-3 border-t border-gray-100 pt-4"></div>
                    </div>
                    
                    <div class="p-4 bg-slate-900 rounded-lg border border-gray-800 shadow-xl">
                        <h4 class="text-xs font-bold text-blue-400 uppercase mb-2">Sistem Verificare Normative</h4>
                        <p class="text-[11px] text-gray-400 leading-relaxed" id="tech-note">Motoarele de calcul utilizează biblioteci matematice de înaltă precizie pentru conversii trigonometrice și respectă strict Metodologia Mc001 și Eurocod 3/5.</p>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        const MODULES = {
            // --- BUSINESS & TAXE ---
            'tax-calc': {
                title: "Taxe Autorizare & ISC",
                desc: "Calculul taxelor legale pentru obținerea AC și cotele către ISC și Timbru Arhitectural.",
                cat: 'management',
                icon: 'banknote',
                inputs: [
                    { id: 'val_lucrari', label: 'Valoare Lucrări (RON)', type: 'number', val: 500000 },
                    { id: 'tax_ac', label: 'Cota Taxă AC (%)', type: 'number', val: 0.5 }
                ],
                calc: (data) => {
                    const isc_control = data.val_lucrari * 0.001;
                    const isc_autoriz = data.val_lucrari * 0.005;
                    const timbru = data.val_lucrari * 0.0005;
                    const local_tax = data.val_lucrari * (data.tax_ac / 100);
                    return { 
                        main: (local_tax + isc_control + isc_autoriz + timbru).toLocaleString(), unit: 'RON', 
                        sub: [
                            { label: 'Taxă Primărie (AC)', val: local_tax.toLocaleString(), unit: 'RON' },
                            { label: 'ISC (0.1% + 0.5%)', val: (isc_control + isc_autoriz).toLocaleString(), unit: 'RON' },
                            { label: 'Timbru Arhitectural', val: timbru.toLocaleString(), unit: 'RON' }
                        ],
                        dims: [10, 2, 10]
                    };
                }
            },

            // --- NOILE CALCULATOARE DE PANTA (REPARATE SI PRECISE) ---
            'deg-to-perc': {
                title: "Grade în Procent (%)",
                desc: "Conversie trigonometrică de înaltă precizie din unghi în pantă procentuală (Precizie 10^-8).",
                cat: 'slopes',
                icon: 'corner-right-up',
                inputs: [
                    { id: 'degree', label: 'Unghi Grade (0-89.9°)', type: 'number', val: 4.5735 },
                    { id: 'dist_horiz', label: 'Distanță Orizontală (m)', type: 'number', val: 10.0 }
                ],
                calc: (data) => {
                    const rad = data.degree * (Math.PI / 180);
                    const slopePerc = Math.tan(rad) * 100;
                    const h_diff = data.dist_horiz * Math.tan(rad);
                    return {
                        main: slopePerc.toFixed(6), unit: '% Pantă',
                        sub: [
                            { label: 'Diferență Nivel (H)', val: h_diff.toFixed(4), unit: 'm' },
                            { label: 'Lungime Rampă (L)', val: (data.dist_horiz / Math.cos(rad)).toFixed(4), unit: 'm' },
                            { label: 'Raport 1:x', val: `1:${(100/slopePerc).toFixed(3)}`, unit: '' }
                        ],
                        dims: [data.dist_horiz, h_diff, 5]
                    };
                }
            },
            'perc-to-deg': {
                title: "Procent (%) în Grade",
                desc: "Conversie din pantă procentuală în unghi masurat în grade sexagesimale.",
                cat: 'slopes',
                icon: 'rotate-cw',
                inputs: [
                    { id: 'percent', label: 'Pantă în Procent (%)', type: 'number', val: 8.0 },
                    { id: 'dist_horiz', label: 'Distanță Orizontală (m)', type: 'number', val: 10.0 }
                ],
                calc: (data) => {
                    const rad = Math.atan(data.percent / 100);
                    const deg = rad * (180 / Math.PI);
                    const h_diff = data.dist_horiz * (data.percent / 100);
                    return {
                        main: deg.toFixed(6), unit: '° Grade',
                        sub: [
                            { label: 'Diferență Nivel (H)', val: h_diff.toFixed(4), unit: 'm' },
                            { label: 'Unghi în Radiani', val: rad.toFixed(8), unit: 'rad' },
                            { label: 'Verificare Tan(α)', val: (Math.tan(rad)).toFixed(6), unit: '-' }
                        ],
                        dims: [data.dist_horiz, h_diff, 5]
                    };
                }
            },

            // --- ARHITECTURĂ & URBANISM ---
            'stair-calc-pro': {
                title: "Scări (Regula Blondel)",
                desc: "Optimizare treaptă/contratreaptă conform 2h + g = 62-64.",
                cat: 'architecture',
                icon: 'list-ordered',
                inputs: [
                    { id: 'h_tot', label: 'Înălțime de Urcat (cm)', type: 'number', val: 280 },
                    { id: 'g_pref', label: 'Lățime Treaptă dorită (cm)', type: 'number', val: 28 }
                ],
                calc: (data) => {
                    let n = Math.ceil(data.h_tot / 17.5);
                    let h_final = data.h_tot / n;
                    let formula = 2 * h_final + data.g_pref;
                    return {
                        main: n, unit: 'Trepte',
                        sub: [
                            { label: 'Înălțime h', val: h_final.toFixed(2), unit: 'cm' },
                            { label: 'Lățime g', val: data.g_pref, unit: 'cm' },
                            { label: 'Pas Blondel', val: formula.toFixed(1), unit: 'cm' }
                        ],
                        dims: [(n*data.g_pref)/10, data.h_tot/10, 10]
                    };
                }
            },
            'urban-calc': {
                title: "Indici Urbanistici (POT/CUT)",
                desc: "Verificare POT și CUT conform RGU.",
                cat: 'architecture',
                icon: 'map',
                inputs: [
                    { id: 'st', label: 'Suprafață Teren (mp)', type: 'number', val: 500 },
                    { id: 'sc', label: 'S. Construită Sol (mp)', type: 'number', val: 150 },
                    { id: 'sd', label: 'S. Desfășurată (mp)', type: 'number', val: 300 }
                ],
                calc: (data) => {
                    const pot = (data.sc / data.st) * 100;
                    const cut = data.sd / data.st;
                    return { 
                        main: pot.toFixed(2), unit: '% POT', 
                        sub: [
                            { label: 'CUT Realizat', val: cut.toFixed(2), unit: 'idx' },
                            { label: 'S. Liberă Teren', val: (data.st - data.sc).toFixed(1), unit: 'mp' }
                        ],
                        dims: [Math.sqrt(data.st), 0.1, Math.sqrt(data.st)]
                    };
                }
            },

            // --- MODUL NZEB & SUSTENABILITATE 2025 ---
            'pv-yield': {
                title: "Estimare Fotovoltaice (nZEB)",
                desc: "Calcul necesar panouri pentru a acoperi consumul minim reglementat nZEB (30%).",
                cat: 'innovation',
                icon: 'sun',
                inputs: [
                    { id: 'cons_anual', label: 'Consum Estimat (kWh/an)', type: 'number', val: 4500 },
                    { id: 'p_panel', label: 'Putere Panou (Wp)', type: 'number', val: 450 }
                ],
                calc: (data) => {
                    const necesar_nzeb = data.cons_anual * 0.3; // 30% din surse regenerabile
                    const nr_panouri = Math.ceil(necesar_nzeb / (data.p_panel * 1.1)); // Factor mediu RO
                    return {
                        main: nr_panouri, unit: 'Bucăți',
                        sub: [
                            { label: 'Productie Est.', val: (nr_panouri * data.p_panel * 1.1).toFixed(0), unit: 'kWh/an' },
                            { label: 'Suprafață Ocupată', val: (nr_panouri * 2).toFixed(1), unit: 'mp' },
                            { label: 'Target nZEB (30%)', val: necesar_nzeb.toFixed(0), unit: 'kWh' }
                        ],
                        dims: [5, 0.2, 5]
                    };
                }
            },

            'parking-calc-2025': {
                title: "Necesar Parcare & EV",
                desc: "Calcul locuri parcare conform HCL/RLU și necesar stații încărcare electrice.",
                cat: 'innovation',
                icon: 'truck',
                inputs: [
                    { id: 'nr_apt', label: 'Număr Apartamente', type: 'number', val: 10 },
                    { id: 's_com', label: 'S. Comercială (mp)', type: 'number', val: 100 }
                ],
                calc: (data) => {
                    const locuri_apt = Math.ceil(data.nr_apt * 1.2); // 1 loc + 20% vizitatori
                    const locuri_com = Math.ceil(data.s_com / 40);
                    const total = locuri_apt + locuri_com;
                    const ev_stations = Math.ceil(total * 0.2); // Target 2025: 20% pregatite EV
                    return {
                        main: total, unit: 'Locuri',
                        sub: [
                            { label: 'Din care Vizitatori', val: Math.ceil(data.nr_apt * 0.2), unit: 'Loc' },
                            { label: 'Stații EV Obligatorii', val: ev_stations, unit: 'Stații' },
                            { label: 'S. Parcare Minimă', val: (total * 12.5).toFixed(0), unit: 'mp' }
                        ],
                        dims: [total, 0.1, 10]
                    };
                }
            },

            'masonry-calc': {
                title: "Necesar Zidărie (Cărămidă)",
                desc: "Calcul rapid volum și unități paletizate pentru pereți structurali/nestructurali.",
                cat: 'specialty',
                icon: 'layout-grid',
                inputs: [
                    { id: 'l_perete', label: 'Lungime Totală Zid (m)', type: 'number', val: 20 },
                    { id: 'h_perete', label: 'Înălțime Zid (m)', type: 'number', val: 2.8 },
                    { id: 'g_perete', label: 'Grosime Zid (cm)', type: 'number', val: 25 }
                ],
                calc: (data) => {
                    const vol = data.l_perete * data.h_perete * (data.g_perete / 100);
                    const buc_mc = 44; // Medie caramida 25x30
                    return {
                        main: vol.toFixed(2), unit: 'm³',
                        sub: [
                            { label: 'Total Unități (Est.)', val: Math.ceil(vol * buc_mc), unit: 'Buc' },
                            { label: 'Număr Paleți (1.2mc)', val: Math.ceil(vol / 1.2), unit: 'Pal' },
                            { label: 'Mortar Necesat', val: (vol * 0.1).toFixed(2), unit: 'm³' }
                        ],
                        dims: [data.l_perete, data.h_perete, data.g_perete/10]
                    }
                }
            },

            'concrete-steel': {
                title: "Armare Preliminară",
                desc: "Estimare consum oțel-beton raportat la volumul de beton (Proiectare sustenabilă).",
                cat: 'structural',
                icon: 'anvil',
                inputs: [
                    { id: 'vol_beton', label: 'Volum Beton (mc)', type: 'number', val: 50 },
                    { id: 'dens_otel', label: 'Densitate Oțel (kg/mc)', type: 'number', val: 110 }
                ],
                calc: (data) => {
                    const total_kg = data.vol_beton * data.dens_otel;
                    return {
                        main: (total_kg / 1000).toFixed(2), unit: 'Tone Oțel',
                        sub: [
                            { label: 'Total Kilograme', val: total_kg.toLocaleString(), unit: 'kg' },
                            { label: 'Amprentă CO2 Est.', val: (total_kg * 1.85).toFixed(0), unit: 'kgCO2' },
                            { label: 'Cost Est. (4.5 RON/kg)', val: (total_kg * 4.5).toLocaleString(), unit: 'RON' }
                        ],
                        dims: [5, 5, 5]
                    }
                }
            },

            'ramp-disability': {
                title: "Rampă Dizabilități (NP 051)",
                desc: "Verificare conformitate pantă și lungime pentru accesibilizare persoane cu dizabilități.",
                cat: 'architecture',
                icon: 'accessibility',
                inputs: [
                    { id: 'h_dif', label: 'Diferență Nivel (cm)', type: 'number', val: 45 },
                    { id: 'panta_adm', label: 'Pantă Maximă (%)', type: 'number', val: 8 }
                ],
                calc: (data) => {
                    const lungime_necesara = (data.h_dif / data.panta_adm);
                    const verdict = lungime_necesara > 9 ? "NECESITĂ PODEST" : "OK (Fără Podest)";
                    return {
                        main: lungime_necesara.toFixed(2), unit: 'm Lungime',
                        sub: [
                            { label: 'Verdict Normativ', val: verdict, unit: '' },
                            { label: 'Podest Intermediar', val: lungime_necesara > 9 ? "La fiecare 9m" : "Nu", unit: '' },
                            { label: 'Lățime Liberă Min.', val: 1.2, unit: 'm' }
                        ],
                        dims: [lungime_necesara, data.h_dif/100, 1.2]
                    }
                }
            },

            'window-wall-ratio': {
                title: "Raport Vitrat (WWR)",
                desc: "Calculul raportului dintre suprafața vitrată și fațadă pentru analize termice și lumină naturală.",
                cat: 'physics',
                icon: 'layout',
                inputs: [
                    { id: 'area_fatada', label: 'Suprafață Fațadă (mp)', type: 'number', val: 120 },
                    { id: 'area_vitrat', label: 'Suprafață Geamuri (mp)', type: 'number', val: 18 }
                ],
                calc: (data) => {
                    const ratio = (data.area_vitrat / data.area_fatada) * 100;
                    return {
                        main: ratio.toFixed(1), unit: '% WWR',
                        sub: [
                            { label: 'Optim nZEB', val: "15% - 25%", unit: '' },
                            { label: 'Suprafață Opacă', val: (data.area_fatada - data.area_vitrat), unit: 'mp' },
                            { label: 'Verdict Lumină', val: ratio > 20 ? "OPTIM" : "SCĂZUT", unit: '' }
                        ],
                        dims: [10, 5, 0.2]
                    }
                }
            },

            'acoustic-insulation': {
                title: "Izolare Acustică (Rw)",
                desc: "Estimare indice izolare la zgomot aerian pentru pereti compuși (Legea 121/2019).",
                cat: 'physics',
                icon: 'volume-x',
                inputs: [
                    { id: 'masa_perete', label: 'Masa Perete (kg/mp)', type: 'number', val: 220 },
                    { id: 'gros_strat', label: 'Grosime Vată (cm)', type: 'number', val: 10 }
                ],
                calc: (data) => {
                    const rw = 20 * Math.log10(data.masa_perete) + (data.gros_strat * 0.5);
                    return {
                        main: rw.toFixed(0), unit: 'dB',
                        sub: [
                            { label: 'Normativ Int-Ext', val: "Min. 50dB", unit: '' },
                            { label: 'Verdict Confort', val: rw >= 50 ? "CONFORM" : "INSUFICIENT", unit: '' },
                            { label: 'Atenuare Est.', val: (rw * 0.8).toFixed(0), unit: 'dB' }
                        ],
                        dims: [5, 5, 0.5]
                    }
                }
            },

            // --- REINSERATE DIN ORIGINAL (PENTRU INTEGRITATE) ---
            'wood-beam': {
                title: "Grindă Lemn (Pre-dimens.)",
                desc: "Dimensionare preliminară pentru grinzi de planșeu din lemn (C24).",
                cat: 'structural',
                icon: 'columns',
                inputs: [
                    { id: 'span', label: 'Deschidere Grindă (m)', type: 'number', val: 4.5 },
                    { id: 'dist', label: 'Interax (m)', type: 'number', val: 0.6 }
                ],
                calc: (data) => {
                    let h = (data.span * 100) / 18; 
                    let b = h / 1.5;
                    return {
                        main: `${Math.ceil(b)}x${Math.ceil(h)}`, unit: 'cm',
                        sub: [
                            { label: 'Săgeată estimată', val: (data.span*100/300).toFixed(2), unit: 'cm' },
                            { label: 'Moment Inerție (Ix)', val: ((b*Math.pow(h,3))/12).toFixed(0), unit: 'cm4' }
                        ],
                        dims: [data.span*5, h/2, b/2]
                    };
                }
            },
            'coef-g': {
                title: "Coeficient G (C107)",
                desc: "Calculul coeficientului global de izolare termică pentru clădiri de locuit.",
                cat: 'physics',
                icon: 'thermometer-snowflake',
                inputs: [
                    { id: 'vol', label: 'Volum Interior (mc)', type: 'number', val: 300 },
                    { id: 'area_ext', label: 'S. Anvelopă (mp)', type: 'number', val: 240 },
                    { id: 'r_med', label: 'R medie (mpK/W)', type: 'number', val: 3.5 }
                ],
                calc: (data) => {
                    let g = (1 / data.vol) * (data.area_ext / data.r_med);
                    return {
                        main: g.toFixed(3), unit: 'W/mcK',
                        sub: [
                            { label: 'G admis (normativ)', val: "0.45-0.52", unit: '' },
                            { label: 'Verdict G', val: g < 0.45 ? "EXCELENT" : "LIMITĂ", unit: '' }
                        ],
                        dims: [10, 10, 10]
                    };
                }
            }
        };

        // --- SISTEM ENGINE & RENDER ---
        let activeModule = 'deg-to-perc';
        let scene, camera, renderer, model, controls;

        function init() {
            renderNav();
            init3D();
            loadModule(activeModule);
            lucide.createIcons();
            window.addEventListener('resize', onWindowResize);
        }

        function renderNav() {
            const cats = ['management', 'architecture', 'slopes', 'structural', 'physics', 'innovation', 'specialty'];
            cats.forEach(c => {
                const container = document.getElementById(`nav-${c}`);
                if(container) container.innerHTML = '';
            });

            Object.keys(MODULES).forEach(key => {
                const mod = MODULES[key];
                const container = document.getElementById(`nav-${mod.cat}`);
                if(!container) return;

                const btn = document.createElement('div');
                btn.className = `sidebar-item w-[92%] flex items-center gap-3 px-6 py-3 text-[13px] text-gray-600 hover:bg-gray-100 ${activeModule === key ? 'active' : ''}`;
                btn.onclick = () => loadModule(key);
                btn.innerHTML = `<i data-lucide="${mod.icon}" class="w-4 h-4"></i> ${mod.title}`;
                container.appendChild(btn);
            });
        }

        function loadModule(id) {
            activeModule = id;
            const mod = MODULES[id];
            
            document.querySelectorAll('.sidebar-item').forEach(el => {
                el.classList.remove('active');
                if(el.textContent.trim().includes(mod.title)) el.classList.add('active');
            });

            document.getElementById('current-title').innerText = mod.title;
            document.getElementById('current-desc').innerText = mod.desc;
            
            const inputCont = document.getElementById('input-container');
            inputCont.innerHTML = mod.inputs.map(inp => `
                <div class="space-y-1">
                    <label class="text-[10px] font-bold text-gray-400 uppercase tracking-widest">${inp.label}</label>
                    <input type="${inp.type}" id="f-${inp.id}" value="${inp.val}" oninput="process()" class="input-field w-full">
                </div>
            `).join('');
            
            process();
            lucide.createIcons();
        }

        function process() {
            const mod = MODULES[activeModule];
            const values = {};
            mod.inputs.forEach(inp => {
                const el = document.getElementById(`f-${inp.id}`);
                values[inp.id] = parseFloat(el.value) || 0;
            });

            const res = mod.calc(values);
            document.getElementById('res-main').innerText = res.main;
            document.getElementById('res-unit').innerText = res.unit;
            document.getElementById('res-secondary').innerHTML = res.sub.map(s => `
                <div class="flex justify-between items-center text-[13px]">
                    <span class="text-gray-500 font-medium">${s.label}</span>
                    <span class="font-bold text-slate-800">${s.val} <span class="text-[9px] text-blue-600 uppercase">${s.unit}</span></span>
                </div>
            `).join('');
            
            update3D(res.dims);
        }

        function init3D() {
            const cont = document.getElementById('three-viewport');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            camera = new THREE.PerspectiveCamera(40, cont.clientWidth / cont.clientHeight, 0.1, 1000);
            camera.position.set(15, 12, 15);
            
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(cont.clientWidth, cont.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            cont.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

            const grid = new THREE.GridHelper(20, 20, 0xdadce0, 0xe8eaed);
            scene.add(grid);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0x1a73e8, 1);
            light.position.set(5, 10, 7);
            scene.add(light);
            
            animate();
        }

        function update3D(dims) {
            if (model) scene.remove(model);
            
            const geometry = new THREE.BoxGeometry(
                Math.max(0.1, dims[0]/3), 
                Math.max(0.1, dims[1]/3), 
                Math.max(0.1, dims[2]/3)
            );
            
            const material = new THREE.MeshPhongMaterial({ 
                color: 0x1a73e8, 
                transparent: true, 
                opacity: 0.6,
                shininess: 80
            });
            
            model = new THREE.Mesh(geometry, material);
            const edges = new THREE.EdgesGeometry(geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x0d47a1 }));
            model.add(line);
            
            model.position.y = (dims[1]/3) / 2;
            scene.add(model);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const cont = document.getElementById('three-viewport');
            camera.aspect = cont.clientWidth / cont.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(cont.clientWidth, cont.clientHeight);
        }

        function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            const mod = MODULES[activeModule];
            
            doc.setFillColor(32, 33, 36);
            doc.rect(0, 0, 210, 45, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(22);
            doc.setFont("helvetica", "bold");
            doc.text("CORE-ARCH PLATINUM REPORT", 15, 25);
            doc.setFontSize(10);
            doc.text("SISTEM AVANSAT DE ANALIZĂ ȘI CALCUL NORMATIV v7.0", 15, 32);

            doc.setTextColor(32, 33, 36);
            doc.setFontSize(16);
            doc.text(`MODUL: ${mod.title}`, 15, 60);
            
            doc.setFillColor(232, 240, 254);
            doc.roundedRect(15, 70, 180, 30, 2, 2, 'F');
            doc.setTextColor(25, 103, 210);
            doc.setFontSize(28);
            doc.text(`${document.getElementById('res-main').innerText} ${document.getElementById('res-unit').innerText}`, 25, 90);

            doc.save(`Raport_CORE_ARCH_${activeModule}.pdf`);
        }

        init();
    </script>
</body>
</html>
